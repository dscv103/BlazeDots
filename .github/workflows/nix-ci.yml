name: Nix CI

on:
  push:
    branches:
      - main
  pull_request:

jobs:
  check:
    runs-on: ubuntu-latest
    # Conditional build logic (Phase 1) - skip docs-only changes
    if: >
      (github.event_name != 'push' ||
        !contains(github.event.head_commit.message, '[skip ci]')) &&
      !(github.event_name == 'push' &&
        contains(join(github.event.commits.*.modified, ' '), 'README.md') &&
        !contains(join(github.event.commits.*.modified, ' '), '.nix'))
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          # Enable full parallelism for Nix builds on CI
          extra_nix_config: |
            experimental-features = nix-command flakes
            max-jobs = auto
            cores = 0

      # Shared caching infrastructure with optimized keys (Phase 1)
      - name: Cache Nix store
        uses: actions/cache@v4
        with:
          path: |
            /nix/store
            ~/.cache/nix
          key: nix-store-v2-${{ runner.os }}-${{ hashFiles('flake.lock') }}-${{ hashFiles('flake.nix', 'nix/**/*.nix') }}
          restore-keys: |
            nix-store-v2-${{ runner.os }}-${{ hashFiles('flake.lock') }}-
            nix-store-v2-${{ runner.os }}-

      # Evaluation cache with dependency-based invalidation
      - name: Cache flake evaluation
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/nix/eval-cache-v*
          key: nix-eval-v2-${{ runner.os }}-${{ hashFiles('flake.nix', 'nix/**/*.nix', 'hosts/**/*.nix') }}
          restore-keys: |
            nix-eval-v2-${{ runner.os }}-

      # Tool cache with specific dependency tracking
      - name: Cache formatter tools
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/treefmt
          key: treefmt-v2-${{ runner.os }}-${{ hashFiles('nix/parts/fmt.nix', 'treefmt.toml') }}
          restore-keys: |
            treefmt-v2-${{ runner.os }}-

      - name: Show flake metadata with timing
        run: |
          echo "::group::Flake metadata"
          time nix flake metadata
          echo "::endgroup::"

      # Parallel execution of independent checks
      - name: Run flake checks (with timing and parallel safe operations)
        run: |
          echo "::group::Flake checks"
          start_time=$(date +%s)
          nix flake check --impure --all-systems
          end_time=$(date +%s)
          duration=$((end_time - start_time))
          echo "Flake check completed in ${duration}s"
          echo "::endgroup::"

      # Enhanced formatting check with better error reporting
      - name: Check formatting (strict)
        run: |
          echo "::group::Format checking"
          nix fmt
          if [[ $(git diff --name-only) ]]; then
            echo "::error::Files need formatting:"
            git diff --name-only
            echo ""
            echo "Run 'nix fmt' locally to fix formatting issues."
            git diff --color=always
            exit 1
          fi
          echo "All files properly formatted ✅"
          echo "::endgroup::"

      # Parallel linting checks
      - name: Run linting checks
        run: |
          echo "::group::Linting checks"
          
          # Run statix and deadnix in parallel for faster feedback
          echo "Running statix (Nix linting)..."
          nix run nixpkgs#statix -- check . &
          statix_pid=$!
          
          echo "Running deadnix (dead code detection)..."
          nix run nixpkgs#deadnix -- --fail . &
          deadnix_pid=$!
          
          # Wait for both processes and capture results
          wait $statix_pid
          statix_result=$?
          wait $deadnix_pid
          deadnix_result=$?
          
          if [ $statix_result -ne 0 ]; then
            echo "::error::Statix linting failed"
            exit 1
          fi
          
          if [ $deadnix_result -ne 0 ]; then
            echo "::error::Deadnix found unused code"
            exit 1
          fi
          
          echo "All linting checks passed ✅"
          echo "::endgroup::"

      - name: Evaluate system derivation (with performance tracking)
        run: |
          echo "::group::System evaluation"
          start_time=$(date +%s)
          result=$(nix eval .#nixosConfigurations."blazar".config.system.build.toplevel.drvPath)
          end_time=$(date +%s)
          duration=$((end_time - start_time))
          echo "System evaluation completed in ${duration}s"
          echo "Derivation: $result"
          echo "::endgroup::"

      # Add cache statistics for monitoring (Phase 1)
      - name: Cache statistics and hit rate reporting
        if: always()
        run: |
          echo "::group::Cache Performance Metrics"
          echo "Cache usage statistics:"
          
          # Report cache sizes
          if [ -d ~/.cache/nix ]; then
            nix_cache_size=$(du -sh ~/.cache/nix 2>/dev/null || echo "0")
            echo "Nix cache size: $nix_cache_size"
          fi
          
          if [ -d ~/.cache/treefmt ]; then
            treefmt_cache_size=$(du -sh ~/.cache/treefmt 2>/dev/null || echo "0")
            echo "Treefmt cache size: $treefmt_cache_size"  
          fi
          
          # Basic cache hit detection (Phase 1 implementation)
          if [ -n "$ACTIONS_CACHE_URL" ]; then
            echo "Cache infrastructure: GitHub Actions Cache (v2 keys)"
            echo "Cache scope: Workflow-shared with dependency tracking"
          fi
          
          echo "::endgroup::"
